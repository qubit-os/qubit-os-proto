// QubitOS Hardware Information Protocol
// Copyright 2026 QubitOS Contributors
// SPDX-License-Identifier: Apache-2.0

syntax = "proto3";

package quantum.backend.v1;

import "quantum/common/v1/common.proto";
import "quantum/pulse/v1/pulse.proto";

option java_multiple_files = true;
option java_package = "io.qubitos.backend.v1";

// GetHardwareInfoRequest requests information about a backend.
message GetHardwareInfoRequest {
  // Backend name to query.
  string backend_name = 1;

  // Reserved for future use.
  reserved 50 to 100;
}

// HardwareInfo describes a quantum backend's capabilities and status.
message HardwareInfo {
  // Backend identifier.
  string backend_name = 1;
  
  // Type of backend.
  // Values: "simulator", "hardware"
  string backend_type = 2;
  
  // Deployment tier.
  // Values: "local", "cloud", "on-premise"
  string tier = 3;
  
  // --- Qubit Configuration ---
  
  // Number of qubits in the system.
  int32 num_qubits = 4;
  
  // Indices of qubits available for use.
  // May be a subset of 0..num_qubits-1 if some qubits are offline.
  repeated int32 available_qubit_indices = 5;
  
  // --- Capabilities ---
  
  // Gates supported by this backend.
  repeated quantum.pulse.v1.GateType supported_gates = 6;
  
  // Pulse optimization algorithms supported.
  // Values: "grape", "drag", "gaussian", "square"
  repeated string supported_algorithms = 7;
  
  // Whether state vector output is available.
  bool supports_state_vector = 8;
  
  // Whether noise modeling is available.
  bool supports_noise_model = 9;
  
  // --- Connectivity ---
  
  // Qubit pairs that support two-qubit gates.
  repeated QubitPair connectivity = 10;
  
  // --- Performance ---
  
  // Performance characteristics.
  PerformanceHints performance = 11;
  
  // Resource limits.
  ResourceLimits limits = 12;
  
  // --- Authentication ---
  
  // Whether this backend requires authentication.
  bool requires_auth = 13;
  
  // --- Version Information ---
  
  // Software version of the backend.
  // Example: "qutip-5.0.0" or "iqm-client-1.2.3"
  string software_version = 14;
  
  // Protocol version.
  int32 proto_version = 15;
  
  // --- Status ---
  
  // Current operational status.
  OperationalStatus status = 16;
  
  // Validation status (cross-backend consistency).
  ValidationStatus validation = 17;

  // Reserved for future use.
  reserved 50 to 100;
}

// QubitPair describes a connected pair of qubits.
message QubitPair {
  // First qubit index.
  int32 qubit_a = 1;

  // Second qubit index.
  int32 qubit_b = 2;

  // Two-qubit gates supported on this pair.
  repeated quantum.pulse.v1.GateType supported_gates = 3;

  // Coupling strength in kHz (if known).
  double coupling_strength_khz = 4;

  // Reserved for future use.
  reserved 50 to 100;
}

// PerformanceHints provides latency and throughput information.
message PerformanceHints {
  // Median (P50) latency for single pulse execution in milliseconds.
  double typical_latency_ms = 1;
  
  // 95th percentile latency in milliseconds.
  double p95_latency_ms = 2;
  
  // 99th percentile latency in milliseconds.
  double p99_latency_ms = 3;
  
  // Maximum shots per individual request.
  int32 max_shots_per_request = 4;
  
  // Recommended batch size for optimal throughput.
  int32 recommended_batch_size = 5;
  
  // Maximum requests per second (rate limit).
  double max_requests_per_second = 6;
  
  // Default timeout in milliseconds.
  int32 default_timeout_ms = 7;

  // Reserved for future use.
  reserved 50 to 100;
}

// ResourceLimits specifies maximum allowed values.
message ResourceLimits {
  // Maximum Hilbert space dimension.
  int32 max_hilbert_dim = 1;
  
  // Maximum number of qubits.
  int32 max_qubits = 2;
  
  // Maximum shots per request.
  int32 max_shots = 3;
  
  // Maximum pulse duration in nanoseconds.
  int32 max_pulse_duration_ns = 4;
  
  // Maximum number of time steps per pulse.
  int32 max_time_steps = 5;
  
  // Maximum batch size.
  int32 max_batch_size = 6;
  
  // Maximum concurrent requests.
  int32 max_concurrent_requests = 7;
  
  // Maximum GRAPE iterations.
  int32 max_grape_iterations = 8;

  // Reserved for future use.
  reserved 50 to 100;
}

// OperationalStatus indicates current backend availability.
message OperationalStatus {
  enum Status {
    STATUS_UNKNOWN = 0;
    
    // Backend is fully operational.
    STATUS_ONLINE = 1;
    
    // Backend is operational but with degraded performance.
    STATUS_DEGRADED = 2;
    
    // Backend is undergoing maintenance.
    STATUS_MAINTENANCE = 3;
    
    // Backend is offline.
    STATUS_OFFLINE = 4;
  }
  
  // Current status.
  Status status = 1;
  
  // Human-readable status message.
  string message = 2;
  
  // When status was last updated.
  quantum.common.v1.Timestamp updated_at = 3;
  
  // Expected time when backend will be back online (if offline/maintenance).
  quantum.common.v1.Timestamp expected_recovery = 4;

  // Reserved for future use.
  reserved 50 to 100;
}

// ValidationStatus indicates cross-backend validation results.
message ValidationStatus {
  enum Status {
    VALIDATION_NOT_PERFORMED = 0;
    
    // Backend passed validation.
    VALIDATION_PASSED = 1;
    
    // Backend failed validation.
    VALIDATION_FAILED = 2;
    
    // Validation results have expired.
    VALIDATION_EXPIRED = 3;
  }
  
  // Validation status.
  Status status = 1;
  
  // Validation method used.
  // Example: "hellinger_crosscheck_v1", "state_tomography_v1"
  string method = 2;
  
  // When validation was performed.
  quantum.common.v1.Timestamp validated_at = 3;
  
  // Details about validation (pass/fail reasons).
  string details = 4;
  
  // Validation metrics (e.g., Hellinger distance).
  map<string, double> metrics = 5;

  // Reserved for future use.
  reserved 50 to 100;
}

// HealthRequest checks backend health.
message HealthRequest {
  // Backend to check.
  // If empty, checks all backends.
  string backend_name = 1;

  // Reserved for future use.
  reserved 50 to 100;
}

// HealthResponse contains health check results.
message HealthResponse {
  enum Status {
    // Backend is healthy and accepting requests.
    HEALTH_HEALTHY = 0;
    
    // Backend is operational but with issues.
    HEALTH_DEGRADED = 1;
    
    // Backend is not accepting requests.
    HEALTH_UNAVAILABLE = 2;
  }
  
  // Overall status (worst status if multiple backends checked).
  Status status = 1;
  
  // Human-readable message.
  string message = 2;
  
  // When health check was performed.
  quantum.common.v1.Timestamp checked_at = 3;
  
  // Latency of health check in milliseconds.
  double latency_ms = 4;
  
  // Per-backend status (if backend_name was empty).
  map<string, Status> backend_statuses = 5;
  
  // Per-backend details.
  map<string, string> backend_messages = 6;

  // Reserved for future use.
  reserved 50 to 100;
}
